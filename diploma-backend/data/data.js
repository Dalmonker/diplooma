const uuid = require("uuid");

const links = [
  {
    id: uuid.v4(),
    title: "Основы CSS",
    lessons: [
      {
        title:
          "1. Введение в CSS, его роль в веб-разработке. Подключение стилей",
        id: uuid.v4(),
        link: "/chto-takoe-css",
      },
      {
        title: "2. Простые селекторы, вложенность и вес селектора",
        id: uuid.v4(),
        link: "/selectors",
      },
      {
        title: "3. Единицы измерения CSS, свойство display",
        id: uuid.v4(),
        link: "/units-display",
      },
      {
        title: "4. Размеры, отступы",
        id: uuid.v4(),
        link: "/size",
      },
      {
        title: "5. Знакомство с псевдоклассами и псевдоэлементами",
        id: uuid.v4(),
        link: "/pseudo",
      },
      {
        title: "6. Организация отступов, сброс отступов",
        id: uuid.v4(),
        link: "/indentation",
      },
    ],
  },
  {
    id: uuid.v4(),
    title: "Использование",
    lessons: [
      {
        title: "1. Позиционирование элементов",
        id: uuid.v4(),
        link: "/position",
      },
      {
        title: "2. Обтекание, скролл и управление слоями",
        id: uuid.v4(),
        link: "/scroll",
      },
      {
        title: "3. Работа с цветом и текстом",
        id: uuid.v4(),
        link: "/color-text",
      },
      {
        title: "4. Подключение шрифтов, работа с веб-шрифтами",
        id: uuid.v4(),
        link: "/fonts",
      },
      { title: "5. Фон, границы и тени", id: uuid.v4(), link: "/size" },
      {
        title: "6. Межстрочный, межсимвольный интервал, выравнивание текста",
        id: uuid.v4(),
        link: "/interval",
      },
      {
        title: "7. Размеры элементов",
        id: uuid.v4(),
        link: "/validity",
      },
      {
        title: "8. Списки и ссылки",
        id: uuid.v4(),
        link: "/validity",
      },
      {
        title: "9. Валидность CSS-кода, кодстайл CSS",
        id: uuid.v4(),
        link: "/validity",
      },
    ],
  },
  {
    id: uuid.v4(),
    title: "Задания",
    lessons: [
      {
        title: "Задание 1",
        id: uuid.v4(),
        link: "/task-one",
      },
      {
        title: "Задание 2",
        id: uuid.v4(),
        link: "/task-two",
      },
      {
        title: "Задание 3",
        id: uuid.v4(),
        link: "/task-three",
      },
    ],
  },
  // {
  //   id: uuid.v4(),
  //   title: "Продвинутые техники",
  //   lessons: [
  //     { title: "1. Flexbox", id: uuid.v4(), link: "/flexbox" },
  //     {
  //       title: "2. Комбинаторные селекторы и ключевые слова",
  //       id: uuid.v4(),
  //       link: "/selectors",
  //     },
  //     {
  //       title: "3. Псевдоклассы и псевдоэлементы",
  //       id: uuid.v4(),
  //       link: "/pceudo-class",
  //     },
  //     {
  //       title: "4. Кастомные свойства и кастомизация элементов формы",
  //       id: uuid.v4(),
  //       link: "/customization",
  //     },
  //     {
  //       title: "5. Transition и Transform",
  //       id: uuid.v4(),
  //       link: "/transition",
  //     },
  //     {
  //       title: "6. CSS-градиенты и CSS-функции",
  //       id: uuid.v4(),
  //       link: "/gradients",
  //     },
  //     { title: "7. БЭМ", id: uuid.v4(), link: "/bam" },
  //   ],
  // },
  // {
  //   id: uuid.v4(),
  //   title: "Адаптивность",
  //   lessons: [
  //     { title: "1. Виды верстки", id: uuid.v4(), link: "/kinds" },
  //     { title: "2. Pixel Perfect ", id: uuid.v4(), link: "/pixel-perfect" },
  //     { title: "3. Медиа-запросы ", id: uuid.v4(), link: "/media" },
  //     {
  //       title: "4. Адаптивные изображения ",
  //       id: uuid.v4(),
  //       link: "/adaptive-image",
  //     },
  //   ],
  // },
];

const lessons = [
  {
    slug: "chto-takoe-css",
    id: uuid.v4(),
    blocks: [
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Что такое CSS и зачем его изучают
Бывало ли у вас такое, что при плохом интернет-соединении на веб-сайте сначала появлялся столбец с текстом и ссылками,
а затем только через некоторое время появлялись картинки и стилизованный дизайн страницы?
Это происходит из-за CSS, или каскадных таблиц стилей.
CSS - это инструмент, который определяет визуальное оформление элементов на веб-странице.
В нашей статье мы расскажем, что такое CSS, как он работает и зачем он нужен.

#### Стили – это набор определенных параметров, которые управляют внешним видом и расположением элементов веб-страницы.
Чтобы стало понятно, о чем идет речь, посмотрим на рис. 1.1.

![Logo](https://i.imgur.com/br7Lg0z.png "I am as caption")
*Рис. 1.1. Веб-страница, созданная только на HTML*

Данная веб-страница имеет простое оформление без каких-либо декоративных элементов. Однако при добавлении к ней стилевого оформления CSS тот же самый документ приобретает существенно отличный, более привлекательный внешний вид (см. рис. 1.2).

![Logo](https://i.imgur.com/nnLL1CJ.png "I am as caption")
*Рис. 1.2. Веб-страница, созданная на HTML и CSS*

Изменения значительны, поэтому заглянем в код, чтобы понять, в чем разница (пример 1.1).


\`\`\`
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Lorem</title>
    <meta charset="UTF-8" />
  </head>
  <body>
    <h2>Lorem ipsum</h2>
    <p>
      Lorem ipsum, dolor sit amet consectetur adipisicing elit. Cupiditate
      molestias deleniti ut aliquam perspiciatis dolorem veritatis, eveniet
      inventore iste, quas laborum ratione repellat incidunt totam hic assumenda
      molestiae amet. Odit!
    </p>
  </body>
</html>
\`\`\`
*Пример 1.1. Исходный код документа*

Теперь добавим тег <style>, который отвечает за добавлении CSS кода внутри HTML документа. Данный тег должен размещаться внутри тега head, однако это не обязательно – тег style можно разместить внутри тега body и это будет работать. Содержимое этого тега показано в примере 1.2.

\`\`\`
<style>
      body {
        font-family: Arial, Verdana, sans-serif; /* Семейство шрифтов */
        font-size: 11pt; /* Размер основного шрифта в пунктах  */
        background-color: #f0f0f0; /* Цвет фона веб-страницы */
        color: #333; /* Цвет основного текста */
      }
      h1 {
        color: #a52a2a; /* Цвет заголовка */
        font-size: 24pt; /* Размер шрифта в пунктах */
        font-family: Georgia, Times, serif; /* Семейство шрифтов */
        font-weight: normal; /* Нормальное начертание текста  */
      }
      p {
        text-align: justify; /* Выравнивание по ширине */
        margin-left: 60px; /* Отступ слева в пикселах */
        margin-right: 10px; /* Отступ справа в пикселах */
        border-left: 1px solid #999; /* Параметры линии слева */
        border-bottom: 1px solid #999; /* Параметры линии снизу */
        padding-left: 10px; /* Отступ от линии слева до текста  */
        padding-bottom: 10px; /* Отступ от линии снизу до текста  */
      }
    </style>`,
        },
      },
      {
        type: "test",
        data: {
          title:
            "Требуется задать цвет заголовка зелёным. Какое стилевое свойство подойдёт для этой цели?",
          // description: "Как убрать подчеркивание у ссылки?",
          id: uuid.v4(),
          variants: [
            { title: "font-color", id: uuid.v4() },
            { title: "color", id: "1" },
            { title: "font-family", id: uuid.v4() },
            { title: "font-size", id: uuid.v4() },
          ],
          answer: { title: "color", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title: "Как расшифровывается аббревиатура CSS?",
          // description:
          //   "С помощью какоего свойства можно разместить контент на всю ширину блока?",
          id: uuid.v4(),
          variants: [
            { title: "Colorful Style Sheets", id: uuid.v4() },
            { title: "Cascading Style Sheets", id: "1" },
            { title: "Computer Style Sheets", id: uuid.v4() },
            { title: "Creative Style Sheets", id: uuid.v4() },
          ],
          answer: { title: "Cascading Style Sheets", id: "1" },
        },
      },
    ],
  },
  {
    slug: "selectors",
    id: uuid.v4(),
    blocks: [
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Что такое селекторы в CSS

**Селектор** (от англ. select — выбирать) — это шаблон, который позволяет обратиться к элементу или группе элементов веб-страницы, чтобы применить к ним стили CSS.
Его указывают перед блоком со свойствами:

\`\`\`
<style>
    a {
        text-decoration: none;
    }
</style>
\`\`\`

В примере выше селектор указывает на тег <a> (гиперссылка). Так мы говорим браузеру отключить подчёркивание у **всех ссылок** на странице, устанавливая для свойства text-decoration значение none.
Напишем HTML-код:

\`\`\`
<p>Содержание статьи:</p>
	<ul>
		<li><a href="#">Emmet на практике: пишем HTML</a></li>
		<li><a href="#">Создаём шапку документа</a></li>
		<li><a href="#">Подключаем стили и скрипты</a></li>
		<li><a href="#">Добавляем ссылки</a></li>
		<li><a href="#">Вводим теги</a></li>
	</ul>
\`\`\`

Вот как она выглядит в браузере:

![Logo](https://i.imgur.com/nnVJnRL.png "I am as caption")
*Рис. 2.1. Страница в браузере (без использования стилей написанных выше)*

Есть ненумерованный список со ссылками, которые браузер по умолчанию выделяет синим цветом и подчёркивает. Используем стили выше:

![Logo](https://i.imgur.com/pvQuajC.png "I am as caption")
*Рис. 2.2. Та же страница, но ссылки не подчёркнуты*

CSS-селектор работает! Но это, конечно, далеко не единственный способ обращения к элементам.

### Виды селекторов

Структура реальных проектов гораздо сложнее. Веб-страницы интернет-магазинов, корпоративных сайтов и блогов наполнены множеством вложенных и однотипных элементов — всем нужно задать уникальный дизайн. Если бы мы могли обращаться к ним только по названию, то даже с CSS веб оставался бы хранилищем скучного гипертекста.

К счастью, есть около 20 способов выбрать нужный элемент. Рассмотрим основные.

#### Универсальный селектор
Он применяет стили ко всем элементам страницы и обозначается символом * (звёздочка). С его помощью удобно сбрасывать отступы и задавать значение box‑sizing для всех блочных элементов:

\`\`\`
<style>
  * {
    margin: 0;
    box-sizing: border-box;
  }
</style>
\`\`\`

#### Селектор по тегу (элементу)
Этот селектор CSS применяет стили ко всем элементам с одинаковым тегом. Например, для всех <div>, <h2>, <p> и так далее.

Мы уже познакомились с ним, когда убирали подчёркивание у ссылок:

\`\`\`
<style>
  a {
      text-decoration: none;
    }
</style>
\`\`\`

#### Селектор по идентификатору (id)
Селектор по идентификатору обозначается символом # (решётка) и применяет стили к элементу, для которого задан атрибут id с соответствующим значением. При этом у элемента может быть только один id, и этот id должен быть уникальным в пределах веб-страницы.

\`\`\`
  <p id="intro">Сегодня мы расскажем вам об Emmet.</p> 
  <p id="article_content">В этой статье вы узнаете:</p>
\`\`\`

CSS-код:

\`\`\`
<style>
  #intro{
      color: red;
      font-weight: bold;
    }

  #article_content{
      font-family: sans-serif;
      font-weight: bold;
    }
</style>
\`\`\`

Текст в блоке p с идентификатором intro окрасится в красный, а текст с идентификатором article_content выделится жирным и получит шрифт без засечек:

![Logo](https://i.imgur.com/o8BcoeF.png "I am as caption")
*Рис. 2.3. Скриншот страницы*

#### Селектор по классу (class)
CSS-селектор по классу выбирает элементы, для которых назначен атрибут class с соответствующим значением. При этом один элемент может принадлежать нескольким классам — в таком случае их перечисляют через пробел:

\`\`\`
  <p class="plain_text article">Сегодня мы расскажем вам про Emmet.</p> 
\`\`\`

Абзац входит в классы plain_text и article. Значит, к нему применяются стили обоих классов:

\`\`\`
<style>
  .plain_text{
      font-size: 20px;
    }

  .article{
      font-family: "Montserrat"; 
    }
</style>
\`\`\`

#### Группа селекторов
CSS-селекторы можно сгруппировать, чтобы применить стили к нескольким группам и/или классам элементов. Для этого достаточно перечислить их через запятую:

\`\`\`
<style>
  .plain_text, p, h1, figure, div {
      margin-top: 0;
      margin-left: 0;
  }
</style>
\`\`\`
`,
        },
      },
      {
        type: "test",
        data: {
          title:
            "Какой символ используется для селектора по идентификатору (id)?",
          // description: "descr",
          id: uuid.v4(),
          variants: [
            { title: ".", id: uuid.v4() },
            { title: "#", id: "1" },
            { title: "*", id: uuid.v4() },
            { title: "$", id: uuid.v4() },
          ],
          answer: { title: "#", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title: "Какой символ используется для универсального селектора?",
          // description: "descr",
          id: uuid.v4(),
          variants: [
            { title: "Селектор по тегу", id: uuid.v4() },
            { title: "Селектор по классу", id: uuid.v4() },
            { title: "Селектор по идентификатору", id: uuid.v4() },
            { title: "Универсальный селектор", id: "1" },
          ],
          answer: { title: "Универсальный селектор", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title: "Какой селектор применяет стили ко всем элементам страницы?",
          // description: "descr",
          id: uuid.v4(),
          variants: [
            { title: ".", id: uuid.v4() },
            { title: "#", id: uuid.v4() },
            { title: "*", id: "1" },
            { title: "$", id: uuid.v4() },
          ],
          answer: { title: "*", id: "1" },
        },
      },
    ],
  },
  {
    slug: "units-display",
    id: uuid.v4(),
    blocks: [
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Что такое px, %
Единицы измерения в CSS используют для определения размеров элементов, расстояний, шрифтов и других свойств. Они делятся на абсолютные и относительные.

Абсолютные единицы измерения [привязаны](https://www.w3.org/TR/css3-values/#absolute-lengths) к настоящим физическим размерам. Среди них пиксели, сантиметры, миллиметры, дюймы.

Относительные единицы измерения [описывают](https://www.w3.org/TR/css3-values/#relative-lengths) значения, которые зависят от других значений. Среди них em, rem, vh, ex и другие единицы измерения.

Расскажем про две единицы измерения: **px, %**.

### Для чего использовать

#### px
* Задаёт ширину и высоту элементов: **width: 200px;, height: 100px**;.
* Задаёт отступы и поля: **margin: 10px;, padding: 20px**;.
* Задаёт размер шрифта: **font-size: 16px**;.

#### %
* Размер элементов относительно размеров родительского элемента: **width: 50%;, height: 75%**;.
* Отступы и поля относительно размеров родительского элемента: **margin: 10%;, padding: 5%**;.

### Подробнее о каждой единице

#### px

Давайте начнем с самого распространенного — px (c англ. pixels). Пиксель — это базовая, абсолютная и окончательная единица измерения. Пиксель в CSS — это то, что вы видите на экране. Именно он задает значение разрешению монитора. Все значения браузер при веб-разработке пересчитывает в пиксели.

Итак, давайте разберем разметку, которая у нас есть в интерактивной форме. Например, в первом блоке, есть класс box-px за счет которого мы и будем стилизовать текст, который находится внутри.

\`\`\`
<div class="box box-px">
   <h2>Pixels</h2>
   <p class="text-1">font-size:16px</p>
   <p class="text-2">font-size:8px</p>
   <p class="text-3">font-size:32px</p>
</div>
\`\`\`

Обратите внимание, основные классы дублируются. На всю основную стилизацию влияет класс, который стоит после box. Например, если просмотреть код CSS, то можно увидеть стилизацию .box-px .text-1.

\`\`\`
<style>
  .box-px .text-1 {
    font-size:16px;
  }
</style>
\`\`\`
В примере мы видим значение font-size:16px, то есть то, что написано в классе text-n, то и дублируется в CSS. Это сделано для наглядности. Вы должны понимать, что большинство браузеров по умолчанию имеют значение font-size: 16px. Если убрать свойство .box-px .text-1, то визуально ничего не изменится. При этом если мы вернем свойство назад, то тоже ничего не изменится, потому что это значение заложено по умолчанию в браузере. Однако, все что мы стилизуем далее — видоизменяется:

\`\`\`
<style>
  .box-px .text-2 {
    font-size:8px;
  }
  .box-px .text-3 {
    font-size:32px;
  }
</style>
\`\`\`

Если мы используем значение меньше 16px, то наш текст уменьшается. И наоборот: если мы будем использовать значение больше, то текст увеличится. Звучит логично, не так ли? Но как работают другие единицы изменения? Давайте разбираться дальше.

#### %

Следующее значение, которое мы рассмотрим это проценты (%). Вы же помните, что браузер по умолчанию использует значение 16px? Это значит, что все относительные единицы, которые мы будем использовать в дальнейшем тоже будут преобразовываться в проценты. Но мы этого с вами не увидим, т.к. эти процессы будут проходить внутри браузера.

Значение процентов высчитывается относительно значения свойства родительского тега. Это значит, что если текст будет вложенным, то его значение будет меняться в зависимости от того тега, в который он вложен. Давайте рассмотрим это наглядно. Напишем, тег p, внутри которого будет находиться тег span,и внутри которого разместим еще один span

\`\`\`
  <p>Lorem <span>Lorem<span>Lorem</span></span></p>
\`\`\`

Для тега p добавим следующее:

\`\`\`
<style>
  p {
    font-size: 100%;
  }
</style>
\`\`\`

Если бы мы были браузерами, то высчитали значение font-size: 16px. Далее переходим к span. Стилизуем его:

\`\`\`
<style>
  p>span {
    font-size: 50%;
  }
</style>
\`\`\`

Мы увидим, что вложенный span и тот span, который находится внутри него, стали равнозначны значению 8px. Как мы это посчитали? Итак, font-size: 100% = 16px и если мы берем половину, то есть 50%, то половина этого значения и будет значение 8px.
Теперь давайте стилизуем еще большую вложенность:

\`\`\`
<style>
  p>span>span {
    font-size: 400%;
  }
</style>
\`\`\`

Если бы мы указали здесь значение 200%, вышло бы, что мы взяли 2 раза по 8px, складываем 8px + 8px = 16px. Если мы укажем здесь 400%, то здесь у нас станет значение в два раза больше, то есть 16px * 2 = 32px.
`,
        },
      },
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Свойство display
Свойство display определяет тип отображения элемента, как он будет отображаться на веб-странице: как блок, строчный элемент или каким-то другим способом.

Значения свойства display
* block,
* inline,
* inline-block,
* none.

Теперь разберём на примерах значения свойства display.

**block** — элемент отображается как блок и занимает всю доступную ширину. Новый блок начинается с новой строки. Примером элемента, который имеет значение display: block, может быть div.

\`\`\`
<div class="block">
  <h2>Заголовок блока</h2>
  <p>Текст внутри блока</p>
</div>
\`\`\`

\`\`\`
<style>
  .block {
    display: block;
    background-color: #ccc;
    width: 500px;
    height: 300px;
  }
</style>
\`\`\`

![Logo](https://i.imgur.com/ZVxPV5l.png "I am as caption")
*Рис. 3.1. Скриншот страницы*

**inline** — элемент отображается как строчный элемент и не создаёт новый блок. Элемент занимает столько места, сколько ему нужно для отображения содержимого. Примером элемента, который имеет значение display: inline, может быть span.

\`\`\`
<p>Этот текст <span class="inline">выделенный текст</span> и еще немного текста</p>
\`\`\`

\`\`\`
<style>
  .inline {
    display: inline;
    background-color: yellow;
    padding: 5px;
  }
</style>
\`\`\`

Этот текст **выделенный текст** и еще немного текста

**inline-block** — элемент отображается как строчный элемент, но его содержимое может быть отформатировано как блок.
Элемент занимает столько места, сколько ему нужно для отображения содержимого, но может иметь ширину и высоту. Примером элемента, который имеет значение display: inline-block, может быть button.

\`\`\`
  <div class="inline-block">Этот текст находится на той же строке, что и</div>
  <div class="inline-block">этот текст</div>
\`\`\`

\`\`\`
<style>
  .inline-block {
    display: inline-block;
    background-color: #ccc;
    width: 150px;
    height: 100px;
    padding: 10px;
  }
</style>
\`\`\`

![Logo](https://i.imgur.com/CaSDdRw.png "I am as caption")
*Рис. 3.2. Скриншот страницы*

**none** — элемент не отображается на веб-странице и его содержимое не занимает места. Это может быть полезно для скрытия элементов на странице или для создания анимаций. Примером элемента, который имеет значение display: none, может быть script.

\`\`\`
  <div class="hidden">Этот элемент скрыт</div>
\`\`\`

\`\`\`
<style>
  .hidden {
    display: none;
  }
</style>
\`\`\`

Пример использования свойства displayс разными значениями.

\`\`\`
  <div class="block-example">
    Этот блочный элемент занимает всю ширину.   
  </div>

  <span class="inline-example">
    Этот строчный элемент занимает только столько места, сколько ему нужно.
  </span>

  <button class="inline-block-example">
    Этот элемент имеет значение inline-block, поэтому его содержимое может быть отформатировано как блок и иметь ширину и высоту.
  </button>

  <div class="hidden-element">
    Этот элемент имеет значение none, поэтому он не отображается на веб-странице.
  </div>

<style>
  .block-example {
    display: block;
    background-color: yellow;
  }

  .inline-example {
    display: inline;
    background-color: pink;
  }

  .inline-block-example {
    display: inline-block;
    background-color: lightblue;
    width: 200px;
    height: 50px;
  }

  .hidden-element {
    display: none;
  }
</style>
\`\`\`

![Logo](https://i.imgur.com/ztGedK2.png "I am as caption")
*Рис. 3.3. Скриншот страницы*

Блочный элемент имеет жёлтый фон, строчный элемент — розовый фон, элемент button — голубой фон и имеет ширину и высоту, а скрытый элемент не отображается на странице.
`,
        },
      },
      {
        type: "test",
        data: {
          title: "Что обозначает единица измерения px?",
          // description: "descr",
          id: uuid.v4(),
          variants: [
            { title: "Процент от родительского элемента", id: uuid.v4() },
            {
              title: "Пиксель, минимальная единица измерения на экране",
              id: "1",
            },
            { title: "Ширина родительского элемента", id: uuid.v4() },
            { title: "Высота экрана", id: uuid.v4() },
          ],
          answer: { title: "2", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title: "Какое значение свойства display делает элемент блочным?",
          // description: "descr",
          id: uuid.v4(),
          variants: [
            { title: "inline", id: uuid.v4() },
            { title: "block", id: "1" },
            { title: "inline-block", id: uuid.v4() },
            { title: "none", id: uuid.v4() },
          ],
          answer: { title: "block", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title:
            "Какое значение свойства display скрывает элемент с веб-страницы?",
          // description: "descr",
          id: uuid.v4(),
          variants: [
            { title: "hidden", id: uuid.v4() },
            { title: "block", id: uuid.v4() },
            { title: "none", id: "1" },
            { title: "invisible", id: uuid.v4() },
          ],
          answer: { title: "none", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title:
            "Какое значение свойства display делает элемент строчным, но позволяет задавать ширину и высоту?",
          // description: "descr",
          id: uuid.v4(),
          variants: [
            { title: "block", id: uuid.v4() },
            { title: "inline", id: uuid.v4() },
            { title: "inline-block", id: "1" },
            { title: "flex", id: uuid.v4() },
          ],
          answer: { title: "inline-block", id: "1" },
        },
      },
    ],
  },
  {
    slug: "size",
    id: uuid.v4(),
    blocks: [
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Размеры, отступы

В CSS размеры и отступы используются для управления расположением элементов на веб-странице. В CSS есть несколько ключевых свойств для настройки размеров и отступов:       

### Свойства размеров

#### Ширина и высота

* width: задает ширину элемента.
* height: задает высоту элемента

\`\`\`
<style>
  .element {
      width: 100px; /* или 50%, auto и т.д. */
      height: 200px; /* или 50%, auto и т.д. */
  }
</style>
\`\`\`

#### Минимальная и максимальная ширина/высота:

* min-width: задает минимальную ширину элемента.
* min-height: задает минимальную высоту элемента.
* max-width: задает максимальную ширину элемента.
* max-height: задает максимальную высоту элемента.

\`\`\`
<style>
  .element {
      min-width: 50px;
      max-width: 500px;
      min-height: 100px;
      max-height: 400px;
  }
</style>
\`\`\`

#### Внешние отступы (margin):

* margin: задает внешние отступы со всех сторон. Можно задать margin для каждой стороны элемента (верх, низ, лево, право) отдельно.
* margin-top: задает внешний отступ сверху.
* margin-right: задает внешний отступ справа.
* margin-bottom: задает внешний отступ снизу.
* margin-left: задает внешний отступ слева.

\`\`\`
<style>
  .element {
      margin: 10px; /* одинаковый отступ со всех сторон */
      margin: 10px,20px,4px,2px (верх, низ, лево, право);
      margin-top: 20px;
      margin-right: 15px;
      margin-bottom: 25px;
      margin-left: 30px;
  }
</style>
\`\`\`

![Logo](https://i.imgur.com/Oimxi4L.png "I am as caption")
*Рис. 4.1. Скриншот*

#### Внутренние отступы (padding):

* padding: задает внутренние отступы со всех сторон.
* padding-top: задает внутренний отступ сверху.
* padding-right: задает внутренний отступ справа.
* padding-bottom: задает внутренний отступ снизу.
* padding-left: задает внутренний отступ слева.

\`\`\`
<style>
  .element {
      padding: 10px; /* одинаковый отступ со всех сторон */
      padding-top: 20px;
      padding-right: 15px;
      padding-bottom: 25px;
      padding-left: 30px;
  }
</style>
\`\`\`
`,
        },
      },
      {
        type: "test",
        data: {
          title: "Что такое margin в CSS?",
          id: uuid.v4(),
          variants: [
            {
              title: "Свойство, задающее внутренние отступы элемента",
              id: uuid.v4(),
            },
            {
              title: "Свойство, задающее внешние отступы элемента",
              id: "1",
            },
            {
              title: "Свойство, задающее ширину элемента",
              id: uuid.v4(),
            },
            {
              title: "Свойство, задающее высоту элемента",
              id: uuid.v4(),
            },
          ],
          answer: { title: "2", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title:
            "Какое значение имеет свойство margin, если указано одно число?",
          id: uuid.v4(),
          variants: [
            {
              title: "Значение применяется только к верхнему отступу",
              id: uuid.v4(),
            },
            {
              title: "Значение применяется только к нижнему отступу",
              id: uuid.v4(),
            },
            {
              title: "Значение применяется ко всем четырем сторонам элемента",
              id: "1",
            },
            {
              title: "Значение применяется только к левому и правому отступам",
              id: uuid.v4(),
            },
          ],
          answer: { title: "3", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title:
            "Какое значение применится к правому отступу, если margin задан как 10px 20px?",
          id: uuid.v4(),
          variants: [
            { title: "10px", id: uuid.v4() },
            { title: "20px", id: "1" },
            { title: "30px", id: uuid.v4() },
            { title: "40px", id: uuid.v4() },
          ],
          answer: { title: "20px", id: "1" },
        },
      },
    ],
  },
  {
    slug: "indentation",
    id: uuid.v4(),
    blocks: [
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Правила организации отступов
### Основные принципы работы с отступами

У любого сайта или документа есть «поток» — порядок вывода объектов в документе. В вёрстке поток идёт сверху вниз, слева направо. Именно поэтому, если какой-то элемент на макете находится справа, в HTML-коде он должен идти последним в своей группе.

Исходя из этого можно сформулировать первый принцип.

#### 1. Отступы задаются от предыдущего элемента к следующему

Это значит, что в вёрстке нужно стараться использовать CSS-свойства margin-right и margin-bottom, то есть отступ справа и отступ снизу.

![Logo](https://i.imgur.com/bVNZnlB.png "I am as caption")
*Рис. 6.1. На скриншоте видно, как правильно задавать отступы: только справа и снизу (показано оранжевым)*

Внешние отступы сверху и слева (margin-top и margin-left) заменяются на аналогичные внутренние отступы (padding) у родительского элемента.

![Logo](https://i.imgur.com/OZiR70C.png "I am as caption")
*Рис. 6.2. Скриншот страницы*

Получается, что блок не может сдвигаться благодаря своим отступам — он делает это только за счёт соседних элементов и сам двигает соседние.

#### 2. Отступы задаются только между соседними элементами в потоке

Если у блока нет соседа с левой стороны — задавать ему отступ слева нельзя. То же самое касается любой из сторон.

Давайте взглянем на пример:

![Logo](https://i.imgur.com/Spbijk6.png "I am as caption")
*Рис. 6.3. Скриншот страницы*

На скриншоте — простой блок: два списка, разделённые отступами.

У обоих задан отступ снизу. Для первого списка это применимо, потому что есть сосед снизу — второй список. А для второго, не имеющего такого соседа, — отступа нет.

![Logo](https://i.imgur.com/A86kWwv.png "I am as caption")
*Рис. 6.4. Скриншот страницы*

На скриншоте типичная ошибка вёрстки: выпадение отступов. Отступ есть, но он не увеличивает размер «родителя» с голубым фоном.

#### 3. Последнему элементу группы нужно обнулять отступ

Это легко сделать с помощью псевдоклассов в CSS. Например, с помощью :last-child, который позволяет выбрать последний элемент из группы.

В нашем случае мы найдём последний элемент списка. :last-child обнуляет отступ у последнего ul. Теперь всё работает как надо.

\`\`\`
<style>
    ul {
      margin-bottom: 30px;
    }

    ul:last-child {
      margin-bottom: 0;
    }
</style>
\`\`\`

Чтобы не создавать два селектора, можно написать короче, используя псевдокласс :not. Тут мы буквально говорим следующее: «Задай отступ всем ul, кроме последнего».

\`\`\`
<style>
    ul:not(:last-child) {
      margin-bottom: 30px;
    }
</style>
\`\`\`

#### 4. Нельзя задавать отступы БЭМ-блокам

Следующий принцип касается БЭМ — специального подхода к именованию классов. Есть такая сущность, как БЭМ-блок: его можно вставлять в любую часть сайта, и стили перенесутся вместе с ним. Подробно о том, как работать с БЭМ, можно почитать тут.

Представьте, что БЭМ-блок используется и в шапке, и в подвале сайта. При этом в шапке ему нужен отступ, а в подвале — нет.

Если такому блоку задать отступы, возникнет проблема. Отступы появятся и там и там — ведь стили БЭМ-блока, как мы помним, переносятся. Именно поэтому отступы обычно делают через модификаторы или миксование классов.

\`\`\`
  <div class="card">
    <h4 class="title">Заголовок карточки</h4>
    <p>Описание в две строки</p>
  </div>
  <div class="card">
    <h4 class="title title--2">Заголовок карточки</h4>
    <p>Описание в две строки</p>
  </div>
\`\`\`

В этом примере есть два заголовка (БЭМ-блока) title. И именно второму из них нужно задать отступ. Для этого используем модификатор .title--2, но не делаем отступ для всех .title на странице.

### Типичный пример: отступы в карточке
Рассмотрим реализацию карточки с контентом на сайте. Как здесь лучше поступить?

В нашем примере самая простая карточка: с картинкой, заголовком и описанием. Как правильнее сделать отступы у заголовка и описания? На самом деле всё очень просто: нужно применить принципы, о которых я рассказал.

![Logo](https://i.imgur.com/eZHWmiy.png "I am as caption")
*Рис. 6.4. На скриншоте — вполне типичная карточка товара с картинкой, заголовком, описанием и ценой*

Нам достаточно обернуть весь текст карточки в блок и задать блоку внутренний отступ — padding. Так наша вёрстка будет соответствовать сразу трём принципам. А чтобы сделать отступ между заголовком и описанием, достаточно просто сделать отступ снизу — для заголовка.

### Выводы

Итак, повторим принципы работы с отступами:
* Отступы задаются от предыдущего элемента к следующему.
* Отступы задаются только между соседними элементами в потоке.
* Последнему элементу группы нужно обнулять отступ.
* Нельзя задавать отступы БЭМ-блокам.

Это четыре основных правила организации отступов, которые помогут вам сделать вёрстку качественной и гибкой. Главное — начать им следовать. Со временем их соблюдение войдёт в привычку, и вы будете понимать, где можно допустить ошибку и как её избежать.
`,
        },
      },
    ],
  },
  {
    slug: "interval",
    id: uuid.v4(),
    blocks: [
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Межсимвольный, межстрочный интервал CSS. Расстояние между словами
Работая со стилем для текста, вы можете устанавливать необходимые расстояния между символами, словами и строками. Задаются такие расстояния в любых единицах измерения CSS, будь-то px, pt, em или другое. Исключением являются проценты – с их помощью можно задать расстояние между строками (интерлиньяж), но они не работают при установке интервала между символами или словами.

### Межсимвольный интервал CSS: letter-spacing

Задать межсимвольный интервал можно с помощью свойства CSS letter-spacing. Помимо обычных значений (положительных и отрицательных) также можно использовать значения inherit (чтобы наследовать значение у родителя) и normal (если необходимо вернуть нормальное расстояние между символами).

Пример записи межсимвольного интервала:

\`\`\`
  p {
    letter-spacing: 2em;
  }
\`\`\`

### Интервал между словами: word-spacing

Свойство CSS word-spacing отличается от предыдущего тем, что устанавливает расстояние между словами, а не между символами. Для данного свойства тоже предусмотрены значения normal и inherit. Можно задавать отрицательные значения. Ниже показан пример записи стиля:

\`\`\`
  p {
    word-spacing: 6px;
  }
\`\`\`

### Межстрочный интервал: line-height
С помощью свойства CSS line-height можно задавать расстояние между строками текста. Как было сказано в начале темы, для установки интерлиньяжа, помимо других единиц измерения, допускается использовать проценты. Также разрешено записывать значение в виде множителя (числа больше 0): для вычисления расстояния браузер умножит размер шрифта на заданное число. Отрицательные значения не работают. Доступны значения normal и inherit.

Ниже – пример, как сделать межстрочный интервал CSS:

\`\`\`
  p {
    line-height: 180%;
  }
\`\`\`

На скриншоте можно увидеть, как выглядит текст со всеми тремя свойствами:

![Logo](https://i.imgur.com/E9RKmUM.png "I am as caption")
*Рис. 6.1. Скриншот: интервалы в CSS*

### Итоги
Устанавливая интервал между словами, символами или строками, в первую очередь следите за тем, чтобы текст в итоге был легко читаем. С подобными свойствами необходимо обращаться аккуратно и всегда использовать их в меру, без фанатизма, иначе все текстовое содержимое грозит превратиться в неразборчивый набор букв.
`,
        },
      },
    ],
  },
  {
    slug: "pseudo",
    id: uuid.v4(),
    blocks: [
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Псевдоклассы и псевдоэлементы
**Псевдоклассы** в CSS – это способ указать на специальное состояние элемента, например, когда курсор наведен (:hover) или элемент выбран (:focus). Это помогает менять стиль элементов без изменения кода, делая страницу более интерактивной. 🎨✨

**Псевдоклассы** решают проблему необходимости добавления или изменения HTML-кода для стилизации элементов в различных состояниях. Это значит, что можно динамически изменять внешний вид веб-страницы, реагируя на действия пользователя, не затрагивая основную структуру документа. 🚀

Это важно, потому что упрощает написание программ и делает код более чистым и легким для поддержки. Кроме того, позволяет создавать более интерактивные и привлекательные веб-страницы, что является ключевым для улучшения пользовательского опыта. 🌟

#### Пример

Представьте, что вы создаёте веб-страницу с кнопкой, которая должна менять свой цвет с серого на синий, когда пользователь наводит на неё курсор мыши. Это типичная задача, с которой сталкиваются многие начинающие веб-разработчики. Использование псевдокласса :hover в CSS позволяет решить эту задачу просто и эффективно, без необходимости добавления JavaScript кода для обработки событий мыши.

\`\`\`
<style>
    .button {
      background-color: grey; /* Исходный цвет кнопки */
      color: white; /* Цвет текста на кнопке */
      padding: 10px 20px; /* Паддинги для увеличения размера кнопки */
      border: none; /* Убираем стандартную рамку кнопки */
      cursor: pointer; /* Меняем курсор, чтобы пользователь понимал, что это кнопка */
    }

    .button:hover {
      background-color: blue; /* Цвет кнопки при наведении курсора */
    }
</style>
\`\`\`

В этом примере мы создаём стили для элемента с классом **.button**, задавая ему исходный серый цвет фона и белый цвет текста. Затем, используя псевдокласс **:hover**, мы определяем, что при наведении курсора мыши на кнопку её фоновый цвет должен измениться на синий. Это простой и понятный способ сделать интерфейс более динамичным и отзывчивым к действиям пользователя, улучшая взаимодействие с веб-страницей.

#### Основы псевдоклассов и как они работают

**Псевдоклассы CSS** – это ключ к созданию динамичных и интерактивных веб-страниц. Они позволяют стилизовать элементы, когда определённые условия истинны, без необходимости добавлять классы или идентификаторы в HTML. Это делает код более чистым и упрощает его поддержку.

**Почему псевдоклассы так важны?**
* Упрощение кода: Позволяют избежать лишнего JavaScript или изменений в HTML.
* Реакция на пользователя: Меняют стиль элементов в ответ на действия пользователя, например, при наведении курсора или фокусировке.
* Доступность: Улучшают взаимодействие с сайтом для пользователей с ограниченными возможностями.

**Примеры псевдоклассов**
* :hover – изменяет стиль элемента при наведении курсора.
* :focus – применяется к элементу, когда он получает фокус.

#### Псевдоэлементы: дополнение к псевдоклассам

**Псевдоэлементы** позволяют стилизовать определённые части элемента, как будто добавляя виртуальные элементы в HTML. Это мощный инструмент для создания уникальных дизайнов без изменения исходного кода страницы.

Как псевдоэлементы улучшают дизайн?
* Вставка контента: С помощью ::before и ::after можно добавлять текст или декоративные элементы до или после содержимого элемента.
* Стилизация частей элемента: Например, можно изменять внешний вид первой буквы параграфа с помощью ::first-letter.

Пример использования псевдоэлементов

\`\`\`
<style>
    p::first-letter {
      font-size: 200%; /* Увеличиваем размер первой буквы параграфа */
      color: red; /* Меняем цвет на красный */
    }
</style>
\`\`\`

### Преимущества и ограничения
Псевдоклассы и псевдоэлементы добавляют гибкость и мощность в CSS, позволяя создавать более интерактивные и привлекательные веб-страницы. Однако, важно помнить, что их использование должно быть обоснованным и не усложнять поддержку кода.

* Преимущества: Упрощение и оптимизация кода, улучшение пользовательского опыта.
* Ограничения: Необходимо избегать чрезмерного использования, которое может затруднить чтение и поддержку кода.

Псевдоклассы и псевдоэлементы – мощные инструменты для веб-разработчиков. Они позволяют создавать динамичные, интерактивные и красивые веб-страницы, улучшая взаимодействие с пользователем и облегчая процесс разработки.
`,
        },
      },
      {
        type: "test",
        data: {
          title: "Какое из перечисленных ключевых слов является псевдоклассом?",
          id: uuid.v4(),
          variants: [
            {
              title: "::before",
              id: uuid.v4(),
            },
            {
              title: ":hover",
              id: "1",
            },
            {
              title: "::after",
              id: uuid.v4(),
            },
            {
              title: ":content",
              id: uuid.v4(),
            },
          ],
          answer: { title: ":hover", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title:
            "Какое из перечисленных ключевых слов является псевдоэлементом?",
          id: uuid.v4(),
          variants: [
            {
              title: ":focus",
              id: uuid.v4(),
            },
            {
              title: ":visited",
              id: uuid.v4(),
            },
            {
              title: "::first-line",
              id: "1",
            },
            {
              title: ":nth-child",
              id: uuid.v4(),
            },
          ],
          answer: { title: "::first-line", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title: "Что из перечисленного делает псевдокласс :first-child?",
          id: uuid.v4(),
          variants: [
            {
              title: "Применяет стиль к последнему дочернему элементу родителя",
              id: uuid.v4(),
            },
            {
              title: "Применяет стиль ко всем дочерним элементам",
              id: uuid.v4(),
            },
            {
              title: "Применяет стиль к первому дочернему элементу родителя",
              id: "1",
            },
            {
              title: "Применяет стиль к среднему дочернему элементу",
              id: uuid.v4(),
            },
          ],
          answer: { title: "3", id: "1" },
        },
      },
    ],
  },
  // -----------
  {
    slug: "position",
    id: uuid.v4(),
    blocks: [
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Позиционирование элементов
Чтобы создавать сложные макеты или интерактивные элементы, нужно управлять местоположением элементов на странице. Для этого есть CSS-свойство position. Оно определяет, где находится элемент на веб-странице.

Значения свойства position
Значения position:
* static — значение по умолчанию, элемент позиционируется в соответствии с его местом в потоке документа;
* relative — элемент позиционируется относительно своего исходного положения в потоке документа;
* absolute — элемент позиционируется относительно ближайшего родительского элемента, который имеет позиционирование, отличное от static;
* fixed — элемент позиционируется относительно окна браузера;
* sticky — элемент остаётся на месте при прокрутке страницы, но при этом может быть отодвинут от своей стандартной позиции.

**Static**

Static является значением по умолчанию для всех элементов и будет отображаться на странице в соответствии с порядком элемента в документе. Это значение используется редко и, как правило, не требует дополнительных параметров.
Пример использования свойства position со значением static:

\`\`\`
<style>
  #three {
    position: static;
    background: orange;
  }
</style>
<div class="box" id="one">Первый блок</div>
<div class="box" id="two">Второй</div>
<div class="box" id="three">Третий</div>
<div class="box" id="four">Четвёртый</div>
\`\`\`


![Logo](https://i.imgur.com/BIqt1un.png)
*Рис. 2.1. Position: static*

**Relative**

Relative определяет позиционирование элемента относительно его стандартного местоположения на странице. При использовании этого значения можно задать дополнительные параметры, такие как top, bottom, left и right, которые указывают на смещение элемента относительно его стандартного местоположения.

\`\`\`
<style>
  #two {
    position: relative;
    top: 20px;
    left: 20px;
    background: green;
  }
</style>
\`\`\`


![Logo](https://i.imgur.com/ngPyjm9.png "I am as caption")
*Рис. 2.2. Position: relative*

**Absolute**

Absolute задаёт точное местоположение элемента на странице, независимо от других элементов на странице.
При использовании значения можно задать параметры top, bottom, left и right, чтобы определить точное местоположение элемента.

\`\`\`
<style>
  #two {
    position: absolute;
    top: 40px;
    left: 20px;
    background: black;
  }
</style>
\`\`\`


![Logo](https://i.imgur.com/mZQwKO4.png "I am as caption")
*Рис. 2.3. Position: absolute*

**Fixed**

Fixed задаёт элемент на фиксированном месте на странице, независимо от прокрутки страницы.
При использовании этого значения также можно задать параметры top, bottom, left и right, чтобы определить точное местоположение элемента.

\`\`\`
<style>
  #four {
    position: fixed;
    top: 40px;
    left: 10px;
    background: red;
  }
</style>
\`\`\`


![Logo](https://i.imgur.com/evZi7sS.png "I am as caption")
*Рис. 2.4. Position: fixed*

**Sticky**

Sticky начинает себя вести как обычный элемент до тех пор, пока не достигнет определенной позиции на странице, которую вы зададите с помощью свойства **top, right, bottom или left.
Как только элемент достигнет этой позиции при прокрутке страницы, он зафиксируется на месте и будет оставаться там до тех пор, пока пользователь не доскроллит страницу обратно.

\`\`\`
<style>
  #four {
    position: sticky;
    top: 30px;
    left: 10px;
    background: red;
  }
</style>
\`\`\`


![Logo](https://i.imgur.com/hvP8QiF.png "I am as caption")
*Рис. 2.4. Position: sticky*

### Нюансы использования:
* Если у элемента значение свойства position установлено в absolute или fixed, то такой элемент будет выведен из обычного потока документа и может перекрыть другие элементы. Если это не предполагается, то нужно следить за порядком элементов на странице и настройками z-index.

* Если у элемента значение свойства position установлено в relative, то это не влияет на позиции других элементов на странице.

* Значение свойства position может также влиять на поведение других свойств, например, на позиционирование через top, left, bottom и right.

* Использование свойства position вместе с другими свойствами, например, transform или display, может дать неожиданные результаты и требует более тщательного тестирования на разных браузерах и устройствах.

* Значение sticky может привести к проблемам с доступностью. Если элемент со значением sticky перекрывает другие элементы на странице, это может затруднить доступ к этим элементам для людей, использующих скринридеры.
       
### Перейти к выполнению [задания](https://codepen.io/skillbox_weblayout/pen/BaWNGEK).

`,
        },
      },
      {
        type: "test",
        data: {
          title: "Что делает свойство position: relative?",
          id: uuid.v4(),
          variants: [
            {
              title: "Устанавливает элемент относительно окна браузера",
              id: uuid.v4(),
            },
            {
              title:
                "Устанавливает элемент относительно его нормального положения",
              id: "1",
            },
            {
              title:
                "Устанавливает элемент относительно ближайшего предка с position: relative",
              id: uuid.v4(),
            },
            {
              title:
                "Устанавливает элемент относительно ближайшего предка с position: absolute",
              id: uuid.v4(),
            },
          ],
          answer: { title: "2", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title:
            "Какое значение свойства position используется для фиксирования элемента в определенной позиции в окне браузера, независимо от прокрутки страницы?",
          id: uuid.v4(),
          variants: [
            { title: "static", id: uuid.v4() },
            { title: "relative", id: uuid.v4() },
            { title: "absolute", id: uuid.v4() },
            { title: "fixed", id: "1" },
          ],
          answer: { title: "fixed", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title:
            "Какое свойство используется для перемещения элемента относительно его текущей позиции при position: relative?",
          id: uuid.v4(),
          variants: [
            { title: "float", id: uuid.v4() },
            { title: "margin", id: uuid.v4() },
            { title: "offset", id: uuid.v4() },
            { title: "top, right, bottom, left", id: "1" },
          ],
          answer: { title: "top, right, bottom, left", id: "1" },
        },
      },
    ],
  },
  {
    slug: "scroll",
    id: uuid.v4(),
    blocks: [
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Обтекание, скролл и управление слоями
#### Как раньше использовали float

Ранее свойство float было основным способом создания многостолбцовых макетов и управления обтеканием текста вокруг изображений и других элементов. Свойство float позволяет элементу "выплывать" из обычного потока документа и прижиматься к левому или правому краю родительского элемента.

Пример использования float:

![Logo](https://i.imgur.com/bKh5Qkm.png "I am as caption")
*Рис. 2.1. Скриншот страницы*

\`\`\`
<style>
  .image {
    width: 300px;
    float: left;
  }
</style>

  <img src="img/image.png" class="image">
  <p class="text">
    Далеко-далеко за словесными горами в стране гласных и согласных живут рыбные тексты. Вдали
    от всех живут они в буквенных домах на берегу Семантика большого языкового океана.
    Маленький ручеек Даль журчит по всей стране и обеспечивает ее всеми необходимыми
    правилами. Эта парадигматическая страна, в которой жаренные члены предложения залетают
    прямо в рот. Даже всемогущая пунктуация не имеет власти над рыбными текстами, ведущими
    безорфографичный образ жизни. Однажды одна маленькая строчка рыбного текста по имени
    Lorem ipsum решила выйти в большой мир грамматики.
  </p>
\`\`\`

#### Свойства overflow-x и overflow-y

Свойство overflow контролирует, что происходит с содержимым, если оно выходит за границы блока. В зависимости от значения, это свойство может обрезать содержимое, добавлять полосы прокрутки или оставлять содержимое видимым.

* overflow: visible — содержимое не обрезается и может выходить за границы блока.
* overflow: hidden — содержимое обрезается по границам блока, без полос прокрутки.
* overflow: scroll — добавляются полосы прокрутки, даже если содержимое умещается в блок.
* overflow: auto — полосы прокрутки добавляются только при необходимости.

Рассмотрим пример (рис. 2.2):

![Logo](https://i.imgur.com/M4TisOP.png "I am as caption")
*Рис. 2.2. Скриншот страницы*

\`\`\`
<style>
  .image {
    width: 400px;
    height: 200px;
    outline: 3px solid red;
    overflow: visible;
  }
</style>

<div class="overflow">
    Далеко-далеко за словесными горами в стране гласных и согласных живут рыбные тексты. Вдали
    от всех живут они в буквенных домах на берегу Семантика большого языкового океана.
    Маленький ручеек Даль журчит по всей стране и обеспечивает ее всеми необходимыми
    правилами. Эта парадигматическая страна, в которой жаренные члены предложения залетают
    прямо в рот. Даже всемогущая пунктуация не имеет власти над рыбными текстами, ведущими
    безорфографичный образ жизни. Однажды одна маленькая строчка рыбного текста по имени
    Lorem ipsum решила выйти в большой мир грамматики.
</div>
\`\`\`

А теперь заменим **overflow: visible** на **overflow: hidden**

![Logo](https://i.imgur.com/UTlL3mx.png "I am as caption")
*Рис. 2.2. Скриншот страницы*

#### Применение z-index к элементам

Свойство z-index управляет наложением элементов, когда они накладываются друг на друга. Элементы с большим значением z-index будут располагаться поверх элементов с меньшим значением.

Для использования z-index, элемент должен иметь позиционирование, отличное от static (relative, absolute, fixed или sticky).

![Logo](https://i.imgur.com/8KfhJNN.png "I am as caption")
*Рис. 2.2. Скриншот страницы*
`,
        },
      },
      {
        type: "test",
        data: {
          title: "Что делает свойство float в CSS?",
          id: uuid.v4(),
          variants: [
            {
              title:
                "Позволяет элементу плавно двигаться при прокрутке страницы",
              id: uuid.v4(),
            },
            {
              title: "Позволяет элементу обтекать вокруг другого элемента",
              id: "1",
            },
            {
              title: "Устанавливает прозрачность элемента",
              id: uuid.v4(),
            },
            {
              title: "Определяет скорость прокрутки страницы",
              id: uuid.v4(),
            },
          ],
          answer: { title: "2", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title:
            "Какое значение свойства float помещает элемент слева от его родителя?",
          id: uuid.v4(),
          variants: [
            { title: "left", id: "1" },
            { title: "right", id: uuid.v4() },
            { title: "none", id: uuid.v4() },
            { title: "inherit", id: uuid.v4() },
          ],
          answer: { title: "left", id: "1" },
        },
      },
      {
        type: "test",
        data: {
          title: "Что определяет свойство z-index?",
          id: uuid.v4(),
          variants: [
            { title: "Цвет фона элемента", id: uuid.v4() },
            {
              title: "Порядок расположения элемента по оси Z (глубине)",
              id: "1",
            },
            { title: "Размер шрифта элемента", id: uuid.v4() },
            { title: "Прозрачность элемента", id: uuid.v4() },
          ],
          answer: { title: "2", id: "1" },
        },
      },
    ],
  },
  {
    slug: "color-text",
    id: uuid.v4(),
    blocks: [
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Работа с цветом и текстом
#### Цветовые модели

1. **Шестнадцатеричная система**: Цвета в шестнадцатеричной системе представляются как #RRGGBB, где RR, GG и BB — это шестнадцатеричные значения красного, зеленого и синего компонентов цвета.

**color: #ff0000**

2. **RGB (Red, Green, Blue)**: Цвета определяются с помощью функции rgb(), которая принимает три значения от 0 до 255 для красного, зеленого и синего компонентов.

**color: rgb(255, 0, 0)**

3. RGBA: Это расширение RGB, где добавляется альфа-канал для задания прозрачности (от 0 до 1).

**color: rgba(255, 0, 0, 0.5)**

#### Названия цветов

CSS поддерживает набор предопределенных имен цветов, таких как red, blue, green, и т.д.

**color: red**

#### Управление цветом фона

Цвет фона элемента задается с помощью свойства background-color.

**background-color: #00ff00**

### Работа с текстом в CSS

#### Шрифты

1. Семейство шрифтов: Задается с помощью свойства font-family. Можно указать несколько шрифтов, которые будут использоваться как запасные варианты.

**font-family: Arial, sans-serif**

2. Размер шрифта: Управляется с помощью свойства font-size.

**font-size: 16px**

3. Толщина шрифта: Задается свойством font-weight. Значения могут быть ключевыми словами (normal, bold) или числовыми (от 100 до 900).

**font-weight: bold**

4. Стиль шрифта: Определяется с помощью свойства font-style.

**font-style: italic**

#### Выравнивание текста

1. Горизонтальное выравнивание: Управляется свойством text-align.

text-align: center;
`,
        },
      },
    ],
  },
  {
    slug: "fonts",
    id: uuid.v4(),
    blocks: [
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Подключение шрифтов, работа с веб-шрифтами
#### Подключение шрифтов с помощью Google Fonts

Есть простой и удобный способ подключить нестандартный шрифт — использовать Google Fonts. Это бесплатный сервис, с помощью которого можно подключать шрифты, но не хранить их на своём сервере. Чтобы им воспользоваться, необходимо выбрать шрифт и добавить одно или несколько нужных начертаний, а затем вставить в <head> ссылку, которую сгенерирует Google Fonts во вкладке Embed.

Этого достаточно, чтобы шрифт подключился. Теперь его можно использовать в свойстве font-family без каких-либо дополнительных действий.

\`\`\`
<style>
  body {
    font-family: "Roboto", "Arial", sans-serif;
  }
</style>
\`\`\`

После основного шрифта важно указать веб-безопасный. В случае, если нестандартный шрифт не загрузится, браузер воспользуется альтернативным. Его нужно подобрать максимально похожим на основной шрифт.

Плюсы этого способа — простота использования и всегда актуальные версии шрифтов, Google Fonts их часто обновляет. Но у него есть и минус — запросы к сторонним серверам могут негативно повлиять на скорость загрузки страницы. Если выбираете этот способ, стоит обратить внимание на оптимизацию.

#### Подключение шрифтов с помощью @font-face

Есть альтернативный способ, при котором файлы со шрифтами хранятся вместе с остальными ресурсами сайта. Для них принято заводить отдельную директорию в корне проекта — например, fonts. В неё следует поместить файлы для каждого начертания в нужных форматах — в большинстве случаев, если не требуется поддержка старых браузеров, подойдут .woff и .woff2, о которых мы говорили ранее. Шрифты можно скачать на различных ресурсах. При этом всегда нужно обращать внимание на лицензию — некоторые шрифты могут быть недоступны для коммерческого использования.

После того, как шрифты добавлены в проект, их нужно подключить в CSS-файле. Для этого используется правило @font-face. В самом базовом варианте оно будет включать:

* Название шрифта, которое затем нужно использовать, чтобы задать элементам подключённый шрифт.

* Адрес файла со шрифтом, который нужно подключить, и его формат. Если адресов несколько, их можно указать через запятую. В этом случае важен порядок — браузер будет последовательно пытаться подключить файлы. Первым должен быть самый подходящий формат, а далее — запасные варианты.
Также с помощью функции local можно добавить возможность перед загрузкой шрифта с сервера проверить, установлен ли он на компьютере пользователя. Если да, запроса к серверу за шрифтом не будет — при рендеринге используется локальная версия. Но у этого способа есть минус — шрифт на компьютере пользователя может быть устаревшим, и тогда страница отобразится не совсем так, как было задумано.

* Начертания: жирное, курсивное и так далее. Для каждого начертания нужно отдельное правило @font-face.

Базовый вариант правила:

\`\`\`
<style>
      @font-face {
  font-family: "Roboto";
  font-style: normal;
  font-weight: 400;
  /* Браузер сначала попробует найти шрифт локально */
  src: local("Roboto"),
       /* Если не получилось, загрузит woff2 */
       url("/fonts/roboto.woff2") format("woff2"),
       /* Если браузер не поддерживает woff2, загрузит woff */
       url("/fonts/roboto.woff") format("woff");
}

/* Теперь можно использовать шрифт */
body {
  font-family: "Roboto", "Arial", sans-serif;
}
</style>
\`\`\`

Для улучшения производительности правило @font-face лучше всего прописывать в самом начале CSS-файла. Так браузер сможет раньше начать обработку шрифта.

`,
        },
      },
    ],
  },

  //-----------

  {
    slug: "task-one",
    id: uuid.v4(),
    blocks: [
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Стилизация веб-страницы с помощью CSS
### Макет страницы
Вы уже приступили к разработке первого сайта. 
В этом материале вы: 
* Закрепите на практике навыки работы с CSS-стилями и научитесь их подключать к сайту. 
* Добавите классы к элементам и стилизуете их. 
* Добавите отступы и закрепите тему блочной модели.
За шесть шагов вы стилизуете страницу **index.html**, макет которой представлен на изображении ниже:

![Logo](https://diplooma-server.vercel.app/images/task-test.png "I am as caption")
*Рис. 1.1 Итоговый результат*

1. Создание папки проекта и подключение стилей
Этот материал — часть практической работы, которая ждёт вас дальше. Поэтому вам будет удобнее, если вы сразу организуете работу с папками проекта правильно.

2. Создайте папку и скопируйте в неё все файлы из предыдущей практической работы. 
В основной папке создайте папку CSS для хранения файлов со стилями. Для стилизации разрабатываемой страницы вам понадобятся два файла: **normalize.css** и **style.css**. 
Чтобы создать и подключить файл **normalize.css**, выполните следующие действия:

3. Создайте файл **normalize.css** в папке CSS (это удобно делать в редакторе кода).
Скопируйте [CSS-код](https://necolas.github.io/normalize.css/8.0.1/normalize.css).
Вставьте скопированный код в файл **normalize.css**. Не забудьте сохранить его.
Чтобы создать и подключить файл **style.css**, выполните следующие действия:

4. Создайте файл **style.css** в папке CSS.
Скопируйте [CSS-код](https://drive.google.com/file/d/1Q1dyRG7k51v0RRsvWInSWBNmokUTBd7A/view) для базового сброса.
Вставьте скопированный код в файл **style.css**. Не забудьте сохранить его.

Подключите созданные файлы **normalize.css** и **style.css** в файле **index.html** внутри тега **<head>**, как показано на изображении ниже: 

![Logo](https://diplooma-server.vercel.app/images/task-tesk2.png "I am as caption")
*Рис. 1.2 Подключение стилей*

Важно:
* Соблюдайте строгую последовательность подключения стилей. Сначала подключается файл **normalize.css**, после — **style.css**.
* Вся дальнейшая стилизация будет выполняться в файле **style.css**.
Убедитесь, что структура проекта на этом этапе выглядит так:

![Logo](https://diplooma-server.vercel.app/images/task-tesk3.png "I am as caption")
*Рис. 1.3 Структура проекта*
После того как вы подготовили папку для проекта и подключили стили, переходите к стилизации страницы.


`,
        },
      },
    ],
  },
  {
    slug: "task-two",
    id: uuid.v4(),
    blocks: [
      {
        type: "lecture",
        data: {
          id: uuid.v4(),
          text: `# Практика по теме «Позиционирование»
В этой самостоятельной работе предлагаем попрактиковаться в использовании позиционирования элементов в вёрстке.           
Ваша **цель** — научиться применять свойства позиционирования.

Напоминаем: необходимая для выполнения работы информация есть в теоретическом материале.

Что нужно сделать?
Пройдите по [ссылке](https://codepen.io/skillbox_weblayout/pen/BaWNGEK).
Расположите плашку «Акция» в правом верхнем углу карточки, используя позиционирование. Также разместите блок поверх остального контента, используя соответствующее свойство.
Проверим себя?
В качестве самопроверки посмотрите, как должна выглядеть [готовая страница](https://drive.google.com/file/d/1KKwOPLl9Jm-OuGegSiQcCkfZ9i_7mBbe/view).


`,
        },
      },
    ],
  },
];

module.exports = {
  lessons,
  links,
};
